# state variables are in this order: x, y, x_prime, y_prime
deltaT = 1.0 # time interval; in this case it's arbitrary because we are not measuring real time

# initial state
x = matrix([[0.], # x
            [0.], # y
            [0.], # x prime
            [0.]]) # y prime
P = matrix([
            [10., 0., 0., 0.],
            [0., 10., 0., 0.],
            [0., 0., 1000., 0.],
            [0., 0., 0., 1000.] ]) # initial uncertainty
F = matrix([
        [1., 0., deltaT, 0.], # update x = 1 * x + 0 * y + deltaT * x_prime + 0 * y_prime = x + deltaT * x_prime
        [0., 1., 0., deltaT], # update y = 0 * x + 1 * y + 0 * x_prime + deltaT * y_prime = y + deltaT * y_prime
        [0., 0., 1., 0.],     # update x_prime = 0 * x + 0 * y + 1 * x_prime + 0 * y_prime = x_prime
        [0., 0., 0., 1.]      # update y_prime = 0 * x + 0 * y + 0 * x_prime + 1 * y_prime = y_prime
    ]) # next state function

H = matrix([ [1., 0., 0., 0.],
            [0., 1., 0., 0.]]) # measurement function: reflect the fact that we observe x and y but not the two velocities
R = matrix([[0.1, 0.],
            [0., 0.1]]) # measurement uncertainty: use 2x2 matrix with 0.1 as main diagonal
I = matrix([ [1., 0., 0., 0.],
            [0., 1., 0., 0.],
            [0., 0., 1., 0.],
            [0., 0., 0., 1.]  ]) # 4d identity matrix


    # PREDICTION  (based on theory). Uses total probability and convolution
    x = (F * x)               # in Michel van Biezen it's x1 = F * x0 + B * u1 + w1:
    [[0.0],
     [0.0],
     [0.0],
     [0.0]] = [[1.0, 0.0, 1.0, 0.0],
               [0.0, 1.0, 0.0, 1.0],
               [0.0, 0.0, 1.0, 0.0],
               [0.0, 0.0, 0.0, 1.0]] * [[0.0],
                                        [0.0],
                                        [0.0],
                                        [0.0]]

    P = F * P * F.transpose() # + Q  the Q matrix (process noise) is not present here
    [[1010.0, 0.0, 1000.0, 0.0],
     [0.0, 1010.0, 0.0, 1000.0],
     [1000.0, 0.0, 1000.0, 0.0],
     [0.0, 1000.0, 0.0, 1000.0]] = [[1.0, 0.0, 1.0, 0.0],
                                    [0.0, 1.0, 0.0, 1.0],
                                    [0.0, 0.0, 1.0, 0.0],
                                    [0.0, 0.0, 0.0, 1.0]] * [[10.0, 0.0, 0.0, 0.0],
                                                             [0.0, 10.0, 0.0, 0.0],
                                                             [0.0, 0.0, 1000.0, 0.0],
                                                             [0.0, 0.0, 0.0, 1000.0]] *

                                                                [[1.0, 0.0, 0.0, 0.0],
                                                                 [0.0, 1.0, 0.0, 0.0],
                                                                 [1.0, 0.0, 1.0, 0.0],
                                                                 [0.0, 1.0, 0.0, 1.0]]

    measurement = (-8.768958389125574, 0.36167143910061933)
    # MEASUREMENT UPDATE
    Z = matrix([measurement])
    [(-8.768958389125574, 0.36167143910061933)]

    y = Z.transpose() - (H * x)  # Innovation or measurement residual
    [[-8.768958389125574],
     [0.36167143910061933]] = [[-8.768958389125574],
                               [0.36167143910061933]] - [[1.0, 0.0, 0.0, 0.0],
                                                         [0.0, 1.0, 0.0, 0.0]] *
                                                                   [[0.0],
                                                                   [0.0],
                                                                   [0.0],
                                                                   [0.0]]

    S = H * P * H.transpose() + R
    [[1010.1, 0.0],
     [0.0, 1010.1]] = [[1.0, 0.0, 0.0, 0.0],
                       [0.0, 1.0, 0.0, 0.0]] * [[1010.0, 0.0, 1000.0, 0.0],
                                                [0.0, 1010.0, 0.0, 1000.0],
                                                [1000.0, 0.0, 1000.0, 0.0],
                                                [0.0, 1000.0, 0.0, 1000.0]] *

                                                [[1.0, 0.0],
                                                 [0.0, 1.0],
                                                 [0.0, 0.0],
                                                 [0.0, 0.0]] + [[0.1, 0.0],
                                                                [0.0, 0.1]]

    K = P * H.transpose() * S.inverse() # Kalman gain
    [[0.9999009999009999, 0.0],
     [0.0, 0.9999009999009999],
     [0.9900009900009901, 0.0],
     [0.0, 0.9900009900009901]] = [[1010.0, 0.0, 1000.0, 0.0],
                                   [0.0, 1010.0, 0.0, 1000.0],
                                   [1000.0, 0.0, 1000.0, 0.0],
                                   [0.0, 1000.0, 0.0, 1000.0]] * [[1.0, 0.0],
                                                                  [0.0, 1.0],
                                                                  [0.0, 0.0],
                                                                  [0.0, 0.0]] * \
                                                                [[0.00099000099000099, -0.0],
                                                                 [-0.0, 0.00099000099000099]]

    x = x + (K * y)
    [[-8.768090261376923],
     [0.36163563359234285],
     [-8.681277486511805],
     [0.35805508276469594]] = [[0.0],
                               [0.0],
                               [0.0],
                               [0.0]] + [[0.9999009999009999, 0.0],
                                         [0.0, 0.9999009999009999],
                                         [0.9900009900009901, 0.0],
                                         [0.0, 0.9900009900009901]] *
                                        [[-8.768958389125574],
                                         [0.36167143910061933]]

    P = (I - (K * H)) * P
    [[0.09999009999010267, 0.0, 0.09900009900010165, 0.0],
     [0.0, 0.09999009999010267, 0.0, 0.09900009900010165],
     [0.0990000990000226, 0.0, 9.9990099990099, 0.0],
     [0.0, 0.0990000990000226, 0.0, 9.9990099990099]] = ([[1.0, 0.0, 0.0, 0.0],
                                                          [0.0, 1.0, 0.0, 0.0],
                                                          [0.0, 0.0, 1.0, 0.0],
                                                          [0.0, 0.0, 0.0, 1.0]] -
                                                            [[0.9999009999009999, 0.0],
                                                             [0.0, 0.9999009999009999],
                                                             [0.9900009900009901, 0.0],
                                                             [0.0, 0.9900009900009901]] *
                                                            [[1.0, 0.0, 0.0, 0.0],
                                                             [0.0, 1.0, 0.0, 0.0]]) *
                                                        [[1010.0, 0.0, 1000.0, 0.0],
                                                         [0.0, 1010.0, 0.0, 1000.0],
                                                         [1000.0, 0.0, 1000.0, 0.0],
                                                         [0.0, 1000.0, 0.0, 1000.0]]


    return x,P

